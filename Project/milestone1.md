<table><tr><td> <em>Assignment: </em> It114 Milestone1</td></tr>
<tr><td> <em>Student: </em> Adebambo Owoaje (avo)</td></tr>
<tr><td> <em>Generated: </em> 10/17/2023 12:24:02 PM</td></tr>
<tr><td> <em>Grading Link: </em> <a rel="noreferrer noopener" href="https://learn.ethereallab.app/homework/IT114-001-F23/it114-milestone1/grade/avo" target="_blank">Grading</a></td></tr></table>
<table><tr><td> <em>Instructions: </em> <ol><li>Create a new branch called Milestone1</li><li>At the root of your repository create a folder called Project if one doesn't exist yet</li><ol><li>You will be updating this folder with new code as you do milestones</li><li>You won't be creating separate folders for milestones; milestones are just branches</li></ol><li>Create a milestone1.md file inside the Project folder</li><li>Git add/commit/push it to Github (yes it'll be blank for now)</li><li>Create a pull request from Milestone1 to main (don't complete/merge it yet, just have it in open status)</li><li>Copy in the latest Socket sample code from the most recent Socket Part example of the lessons</li><ol><li>Recommended Part 5 (clients should be having names at this point and not ids)</li><li><a href="https://github.com/MattToegel/IT114/tree/Module5/Module5">https://github.com/MattToegel/IT114/tree/Module5/Module5</a>&nbsp;<br></li></ol><li>Fix the package references at the top of each file (these are the only edits you should do at this point)</li><li>Git add/commit the baseline</li><li>Ensure the sample is working and fill in the below deliverables</li><ol><li>Note: The client commands likely are different in part 5 with the /name and /connect options instead of just connect</li></ol><li>Get the markdown content or the file and paste it into the milestone1.md file or replace the file with the downloaded version</li><li>Git add/commit/push all changes</li><li>Complete the pull request merge from step 5</li><li>Locally checkout main</li><li>git pull origin main</li></ol></td></tr></table>
<table><tr><td> <em>Deliverable 1: </em> Startup </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add screenshot showing your server being started and running</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T07.30.19start.png.webp?alt=media&token=7d31c38c-47bd-4545-8975-df5136b4c54b"/></td></tr>
<tr><td> <em>Caption:</em> <p> The screenshot shows the server starting normally after compiling the code and<br>using the &#39;Project.Server 3000&#39; command. <br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 2: </em> Add screenshot showing your client being started and running</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T07.33.37clientconnect.png.webp?alt=media&token=2c9d5d69-0194-4ff6-bd4f-4ee10a7cc880"/></td></tr>
<tr><td> <em>Caption:</em> <p>The client is starting successfully and connecting to the server. The client first<br>needs a name set using the &#39;/name avo&#39; command and then the &#39;/connect<br>localhost:3000&#39; command to connect to the server using the port number.<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 3: </em> Briefly explain the connection process</td></tr>
<tr><td> <em>Response:</em> <p><b>Server-side connection</b><div>The server listens for incoming client connections on a specified port and,<br>upon connection, creates a new ServerThread to handle communication with each client. The<br>ServerThread manages the client&#39;s communication channels, including input and output streams, and processes<br>messages based on their payload type, such as handling connections, disconnections, or messages.<br>The server maintains a list of rooms, allowing clients to join or create<br>rooms for group communication. It supports basic functionalities like sending messages, changing rooms,<br>and creating new rooms.<br></div><div><b>client-side connection</b></div><div>The Client class sets up a socket connection with<br>a server based on user input, handles communication through input and output streams,<br>and processes various commands such as connecting to a server, setting a client<br>name, and sending messages. The program allows the user to interact with the<br>server by inputting messages through the console and receiving messages from the server.<br>The Client class encompasses methods for connecting to the server, sending messages, handling<br>user input, and managing the communication threads. The client listens for input from<br>the user and messages from the server concurrently, providing a basic chat interface<br></div><div>&lt;span<br>style=&quot;font-size: 13px;&quot;&gt;<b>Socket steps until the server is waiting for messages from the client</b></span><br></div><div>&lt;div<br>style=&quot;&quot;&gt;<span style="font-size: 13px;">The server sets up a ServerSocket on a specified port (default<br>is 3001) using&nbsp;</span></div><div style=""><span style="font-size: 13px;">ServerSocket serverSocket = new ServerSocket(port);.</span></div><div style=""><span style="font-size: 13px;">It<br>then enters a loop, waiting for incoming client connections using&nbsp;</span></div><div style=""><span style="font-size: 13px;">Socket<br>incoming_client = serverSocket.accept();.&nbsp;</span></div><div style=""><span style="font-size: 13px;">This call blocks until a client connects.&nbsp;&nbsp;</span><span style="font-size:<br>13px;">The client then creates a Socket and attempts to connect to the server.&nbsp;For<br>each connected client, the server creates a ServerThread object to handle communication with<br>that client. It passes the client&#39;s socket and the current room to the<br>ServerThread constructor.&nbsp;The client uses ObjectOutputStream to send Payload objects to the server, which<br>represents messages or commands.</span></div></div><br></p><br></td></tr>
</table></td></tr>
<table><tr><td> <em>Deliverable 2: </em> Sending/Receiving </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add screenshot(s) showing evidence related to the checklist</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T08.07.54users.png.webp?alt=media&token=826fca36-1163-47dc-9e35-8dc8b8b733b7"/></td></tr>
<tr><td> <em>Caption:</em> <p>The screenshot shows two users currently connected to the system. The users avo<br>and kennedy can connect to the server and send messages to the lobby.<br>Each user receives a copy of the message<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T08.15.56image.png.webp?alt=media&token=bf0cd3a2-5614-4fc1-9ca6-df130075aa4e"/></td></tr>
<tr><td> <em>Caption:</em> <p>The users are able to connect to the server using the /connect localhost:3000<br>command<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T08.20.09image.png.webp?alt=media&token=d64faa29-c14c-4751-a79f-27801b9c855e"/></td></tr>
<tr><td> <em>Caption:</em> <p>Each user is identified by the name they supplied during connection.  The<br>message is broadcasted to all users from the server.<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T08.24.55image.png.webp?alt=media&token=76cfd978-221d-4f7c-8432-ca694cdd5258"/></td></tr>
<tr><td> <em>Caption:</em> <p>The users created and joined different rooms. Inside the room, the user can<br>communicate without the users outside the room receiving the message. The rooms are<br>avo-room and ken-room<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 2: </em> Briefly explain how the messages are sent, broadcasted (sent to all connected clients), and received</td></tr>
<tr><td> <em>Response:</em> <p><b>Client perspective</b><div><div>The client uses the sendMessage() method to send a message to the<br>server. This method takes the message as input and constructs a Payload object<br>with the message and the client&#39;s name. The client then writes this Payload<br>object to the ObjectOutputStream associated with the socket, effectively sending the message to<br>the server. The server will receive and process this message through the ObjectInputStream.</div></div><div><b>Serverthread<br>perspective</b></div><div><div style="">The ServerThread calls the sendMessage() method, passing the sender&#39;s name and the<br>message. Inside sendMessage(), a Payload object is constructed with the message and sender&#39;s<br>name.When the server needs to broadcast a message to all clients, it iterates<br>through the list of connected clients (other ServerThread instances). For each client, it<br>calls the sendMessage() method, passing the sender&#39;s name and the message to be<br>broadcasted.&nbsp;</div></div><div style=""><b>Room perspective</b></div><div style=""><div style="">To send a message to all clients in the<br>room (including the sender), the Room class calls the sendMessage() method, passing the<br>sender ServerThread and the message. Inside sendMessage(), the method iterates through the list<br>of connected clients (instances of ServerThread) in the room. For each client, it<br>calls the sendMessage() method on the client, passing the sender&#39;s name and the<br>message to be sent.Broadcasting a message is essentially the same as sending a<br>message in this context. The sendMessage() method is called for each client in<br>the room, resulting in the broadcast of the message to all connected client.<br>Messages are received by ServerThread instances, not directly by the Room. When a<br>client sends a message, the ServerThread&#39;s run() method listens for incoming messages using<br>in.readObject().</div><div style=""><b>Client perspective(receiving)</b></div><div style=""><div style="">The client continuously listens for input from the console<br>using the Scanner and waits for the user to type a message.When the<br>user types a message and hits enter, the message is read by the<br>Scanner. The client then processes the message and sends it to the server<br>using the sendMessage() method, as described earlier.</div></div></div><div style=""><br></div><br></p><br></td></tr>
</table></td></tr>
<table><tr><td> <em>Deliverable 3: </em> Disconnecting / Terminating </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add screenshot(s) showing evidence related to the checklist</td></tr>
<tr><td><table><tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T09.12.30image.png.webp?alt=media&token=be649382-aaef-4266-9bbb-c5a741e0686a"/></td></tr>
<tr><td> <em>Caption:</em> <p>The client disconnects successfully and the server keeps running. All other clients are<br>informed about the client who disconnected<br></p>
</td></tr>
<tr><td><img width="768px" src="https://firebasestorage.googleapis.com/v0/b/learn-e1de9.appspot.com/o/assignments%2Favo%2F2023-10-17T09.16.06image.png.webp?alt=media&token=ebef2010-cfb8-416b-b3a0-c4edfcede970"/></td></tr>
<tr><td> <em>Caption:</em> <p>The server can disconnect and leave the client running. The clients are however<br>notified about the server status. Once the server is back online, the clients<br>can reconnect back<br></p>
</td></tr>
</table></td></tr>
<tr><td> <em>Sub-Task 2: </em> Briefly explain how the various disconnects/terminations are handled</td></tr>
<tr><td> <em>Response:</em> <p>How a client gets disconnected<div><div>A client gets disconnected from a Socket perspective when<br>the ServerThread detects a null object or an exception during the attempt to<br>read an object from the ObjectInputStream. This typically occurs when the client closes<br>its end of the connection using the /disconnect command or experiences a network<br>issue, resulting in a closed or broken connection. The server then catches the<br>exception, triggers a disconnect, and initiates the cleanup process to close the associated<br>Socket and release resources.<br></div></div><div>How client doesnt crash after server disonnects</div><div>The client program doesn&#39;t<br>crash when the server disconnects or terminates due to the robust error handling<br>and exception management in the provided code. When the server disconnects or terminates,<br>the client&#39;s ObjectInputStream will throw an exception, which is caught and appropriately handled<br>in the Client class. The fromServerThread in the Client class continuously listens for<br>server messages, and if an exception occurs due to a server disconnection, it<br>is caught and processed without crashing the client program. This ensures that the<br>client program remains stable and can handle unexpected server disconnections gracefully.<br></div><div>How server doesnt<br>crash after client disconnects</div><div>The server is designed to handle client disconnections without crashing<br>through careful exception handling and cleanup procedures. When a client disconnects, either intentionally<br>or due to network issues, the ServerThread associated with that client will detect<br>the disconnection and initiate cleanup in the cleanup() method. This method closes the<br>client&#39;s socket and cleans up associated resources, preventing any adverse effects on the<br>server.<br></div><div><br></div><br></p><br></td></tr>
</table></td></tr>
<table><tr><td> <em>Deliverable 4: </em> Misc </td></tr><tr><td><em>Status: </em> <img width="100" height="20" src="https://user-images.githubusercontent.com/54863474/211707773-e6aef7cb-d5b2-4053-bbb1-b09fc609041e.png"></td></tr>
<tr><td><table><tr><td> <em>Sub-Task 1: </em> Add the pull request for this branch</td></tr>
<tr><td> <a rel="noreferrer noopener" target="_blank" href="https://github.com/Bambov81/avo-IT114-001/pull/7">https://github.com/Bambov81/avo-IT114-001/pull/7</a> </td></tr>
<tr><td> <em>Sub-Task 2: </em> Talk about any issues or learnings during this assignment</td></tr>
<tr><td> <em>Response:</em> <p>I have learnt&nbsp; about about error handling and&nbsp; and status control. i have<br>also leant alot about use of classes to interact with other classes within<br>the program.<br></p><br></td></tr>
</table></td></tr>
<table><tr><td><em>Grading Link: </em><a rel="noreferrer noopener" href="https://learn.ethereallab.app/homework/IT114-001-F23/it114-milestone1/grade/avo" target="_blank">Grading</a></td></tr></table>